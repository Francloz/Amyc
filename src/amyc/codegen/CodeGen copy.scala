// package amyc
// package codegen

// import analyzer._
// import ast.Identifier
// import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
// import utils.{Context, Pipeline}
// import wasm._
// import Instructions._
// import Utils._

// // Generates WebAssembly code for an Amy program
// object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
//   def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
//     val (program, table) = v

//     // Generate code for an Amy module
//     def cgModule(moduleDef: ModuleDef): List[Function] = {
//       val ModuleDef(name, defs, optExpr) = moduleDef
//       // Generate code for all functions
//       defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
//         cgFunction(fd, name, false)
//       } ++
//       // Generate code for the "main" function, which contains the module expression
//       optExpr.toList.map { expr =>
//         val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
//         cgFunction(mainFd, name, true)
//       }
//     }

//     // Generate code for a function in module 'owner'
//     def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
//       // Note: We create the wasm function name from a combination of
//       // module and function name, since we put everything in the same wasm module.
//       val name = fullName(owner, fd.name)
//       Function(name, fd.params.size, isMain){ lh =>
//         val locals = fd.paramNames.zipWithIndex.toMap
//         val body = cgExpr(fd.body)(locals, lh)
//         if (isMain) {
//           body <:> Drop // Main functions do not return a value,
//                         // so we need to drop the value generated by their body
//         } else {
//           body
//         }
//       }
//     }

//     // Generate code for an expression expr.
//     // Additional arguments are a mapping from identifiers (parameters and variables) to
//     // their index in the wasm local variables, and a LocalsHandler which will generate
//     // fresh local slots as required.
//     def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
//       expr match {
//         // Variables
//         case  Variable(name)    => GetLocal(locals(name))
        
//         // Literals
//         case  IntLiteral(value)     => Const(value)
//         case  BooleanLiteral(value) => if (value == false) Const(0) else Const(1)
//         case  StringLiteral(value)  => mkString(value)
//         case  UnitLiteral()         => Const(0)
    
//         // // Binary integer operators
//         case Plus(lhs, rhs)       => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
//         case Minus(lhs, rhs)      => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
//         case Times(lhs, rhs)      => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
//         case Mod(lhs, rhs)        => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
//         case LessThan(lhs, rhs)   => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
//         case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
//         case Equals(lhs, rhs)     => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq

//         case AmyDiv(lhs, rhs)        => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
//         case AmyAnd(lhs, rhs)        => cgExpr(lhs) <:> cgExpr(rhs) <:> And
//         case AmyOr(lhs, rhs)         => cgExpr(lhs) <:> cgExpr(rhs) <:> Or

//         // Binary string operation
//         case Concat(lhs, rhs)     => cgExpr(lhs) <:> cgExpr(rhs) <:> Call("String_concat")

//         // Unary operators
//         case Not(e) => Const(0)  <:> cgExpr(e) <:> Sub
//         case Neg(e) => cgExpr(e) <:> Eqz

//         // The ; operator
//         case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)
        
//         // Local variable definition
//         case Let(df, value, body) => 
//           val ptr = lh.getFreshLocal();
//           cgExpr(value) <:>  SetLocal(ptr) <:>  cgExpr(body)(locals + (df.name -> ptr), lh)
        
//         // If-then-else
//         case Ite(cond, thenn, elze) => 
//           cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End

//         // Represents a computational error; prints its message, then exits
//         case Error(msg) => 
//           cgExpr(msg) <:> Call("Std_printString") <:> Unreachable  
          
//         // Match expression
//         case Match(scrut, cases) => 
//           // Create the code for all the cases
//           def concatMatches(value : Int, result : Int, l : List[MatchCase]) : Code = {
//             // Create the code for the case
//             def codeMatch(matz : MatchCase) : Code = {
//               // Create the code and the locals for the pattern comparison
//               def createMatchCaseComparison(v : Int, matz : Pattern) : (Map[Identifier, Int], Code) = {
//                 matz match {
//                   case WildcardPattern() => (Map[Identifier, Int](), Const(1))
//                   case IdPattern(name) => (Map[Identifier, Int](name -> v), Const(1))
//                   case LiteralPattern(lit) => (Map[Identifier, Int](), GetLocal(v) <:> cgExpr(lit) <:> Eq)
                  
//                   case CaseClassPattern(constr, pats) =>
//                     val constrSig = table.getConstructor(constr) getOrElse sys.error("Cnstruction missing in the table.")
//                     // Match the sub-patterns
//                     def matchArgs(objIdx : Int, patterns : List[Pattern]) : List[(Map[Identifier, Int], Code)] = {
//                       patterns match {
//                         case x :: xs => createMatchCaseComparison(objIdx + constrSig.argTypes.length - patterns.length + 1, x) :: matchArgs(objIdx, xs)
//                         case Nil => List()
//                       }
//                     }
//                     // Match the sub-patterns
//                     val matchedArgs = matchArgs(v, pats) 
//                     val constrCheck = GetLocal(v) <:> Const(constrSig.index) <:> Eq
//                     val extraLocals = matchedArgs.map{_._1}.foldLeft(Map[Identifier, Int]())(_ ++ _)
//                     val patComparisons = matchedArgs.map{_._2}
//                     // Create the total comparison
//                     def concatPatternComparisons(l : List[Code]) : Code = {
//                       l match {
//                         case x :: y :: xs => x <:> Eqz <:> If_void <:> Br("check_match") <:> End <:> concatPatternComparisons(y :: xs)
//                         case List(x) =>  x <:> Eqz <:> If_void <:> Br("check_match") <:> End
//                       }
//                     }
//                     // Return the result
//                     val patResult = lh.getFreshLocal()
//                     if (!patComparisons.isEmpty)
//                       (extraLocals, Block("check_match") <:> Const(0) <:> SetLocal(patResult) <:> constrCheck <:> If_void <:> Br("check_match") <:> End <:> concatPatternComparisons(patComparisons) <:> Const(1) <:> SetLocal(patResult) <:> End <:> GetLocal(patResult))
//                     else
//                       (extraLocals, constrCheck)
//                 }
//               }
//               matz match {
//                 case MatchCase(pat, expr) =>  
//                   val (extraLocals, code)  =  createMatchCaseComparison(value, pat)
//                   Block("match_case") <:> code <:> Eqz <:> If_void <:>  Br("match_case") <:> End <:>  cgExpr(expr)(locals ++ extraLocals, lh) <:> SetLocal(result) <:> Br("match") <:> End
//               }
              
//             }
//             l match {
//               case x :: y :: xs => codeMatch(x) <:> concatMatches(value, result, y :: xs)
//               case x :: xs => codeMatch(x)
//               case Nil => sys.error("codeConcat does not allow an empty list as parameter")
//             }
//           }

//           val v  = lh.getFreshLocal();
//           val r = lh.getFreshLocal();
//           cgExpr(scrut) <:> SetLocal(v) <:> Block("match") <:> concatMatches(v, r, cases) <:> Unreachable <:> End <:> GetLocal(r)

//         // Function/constructor call
//         case AmyCall(id, args) => 
//           def codeConcat(l : List[Expr], store : Boolean) : Code = {
//             l match {
//               case x :: y :: xs => 
//                 if (!store)
//                   cgExpr(x) <:> codeConcat(y :: xs, store)
//                 else
//                   cgExpr(x) <:> SetLocal(lh.getFreshLocal()) <:> codeConcat(y :: xs, store)
//               case x :: Nil => 
//                 if (!store)
//                   cgExpr(x) 
//                 else{
//                   val next_param : Int = lh.getFreshLocal();
//                   cgExpr(x) <:> SetLocal(next_param) 
//                 }
//               case Nil => sys.error("codeConcat does not allow an empty list as parameter")
//             }
//           }
//           val funSig = table.getFunction(id) getOrElse (table.getConstructor(id) getOrElse sys.error("Non existent call identifier"))

//           funSig match {
//             case FunSig(_, _, owner) =>
//               val jump : Instruction = Call(s"${owner}_${id.toString}")
//               if (!args.isEmpty)
//                 codeConcat(args, false) <:> jump
//               else 
//                 jump
//             case ConstrSig(_, parent, index) =>
//               val n_args_index = lh.getFreshLocal();
//               if (!args.isEmpty)
//                 Const(index) <:> SetLocal(n_args_index) <:> codeConcat(args, true) <:> Const(n_args_index)
//               else 
//                 Const(index) <:> SetLocal(n_args_index)  <:> Const(n_args_index)

//           }
          
//       }
//     }
    
//     println(program.modules flatMap cgModule);

//     Module(
//       program.modules.last.name.name,
//       defaultImports,
//       globalsNo,
//       wasmFunctions ++ (program.modules flatMap cgModule)
//     )

//   }
// }
